I"!<p>Many google search results led me here. Hope one of yours will lead you here and this post will shorten your suffering.</p>

<!--more-->

<h3 id="but-first-quick-background">But first‚Ä¶ quick background!</h3>

<p>This is me in one of the frames in video (left picture). Assume that camera position in stable, something like surveillance camera. Our goal is to make system witch will tell us where we are in flat space on something like technical projection (right picture). And as always we will use Python.</p>

<p><img src="https://github.com/JakubSzwajka/JakubSzwajka.github.io/blob/master/_posts/_images/homography_1.png?raw=true" alt="Homography_idea" /></p>

<h3 id="just-use-homography-Ô∏è">Just use homography ü§∑‚Äç‚ôÄÔ∏è</h3>

<p>As I said, I tried lots of different approaches which didn‚Äôt work for me and then in some <a href="https://www.youtube.com/watch?v=fVJeJMWZcq8">YT</a> lecture, I found ‚≠êhomography‚≠ê.</p>

<p>I will try to explain it to you in very simple words. I mention our problem is to find corelation between two flat spaces. Basicaly the screen and technical projection of space which camera covers. That corelation between them is called homography ü§Ø.</p>

<p>If you are searching for detailed stuff go to <a href="https://en.wikipedia.org/wiki/Homography_(computer_vision)">wiki page</a>, I will cover using it with python in my case.</p>

<h3 id="what-we-need">What we need?</h3>

<p>Choose four points on your video, if you have more than four it is even better. Now you need to measure where in 2d space of technical projection those points are. Yes, I see it as a disadvantage of this solution too‚Ä¶ you have to be able to be where your camera is pointing to. Another way is to assume more or less distances between those points.</p>

<p>So now we have our input. In my project I‚Äôve made something like camera settings. For each camera there is a JSON file with input values to calculate homography. Src list is list of x and y coordinates on our video. You can use pixels to know it. Dst list is list of points corresponding to src in real space. For example assume that low left corner of your backyard is point (0,0) and measure all other points.</p>

<div class="language-json highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">{</span><span class="w">
  </span><span class="nl">"name"</span><span class="p">:</span><span class="w"> </span><span class="s2">"camera_1"</span><span class="p">,</span><span class="w">
  </span><span class="nl">"src"</span><span class="p">:</span><span class="w"> </span><span class="p">[</span><span class="w">
    </span><span class="p">[</span><span class="mi">501</span><span class="p">,</span><span class="w"> </span><span class="mi">1013</span><span class="p">],</span><span class="w">
    </span><span class="p">[</span><span class="mi">1289</span><span class="p">,</span><span class="w"> </span><span class="mi">1065</span><span class="p">],</span><span class="w">
    </span><span class="p">[</span><span class="mi">849</span><span class="p">,</span><span class="w"> </span><span class="mi">363</span><span class="p">],</span><span class="w">
    </span><span class="p">[</span><span class="mi">1058</span><span class="p">,</span><span class="w"> </span><span class="mi">524</span><span class="p">]</span><span class="w">
  </span><span class="p">],</span><span class="w">
  </span><span class="nl">"dst"</span><span class="p">:</span><span class="w"> </span><span class="p">[</span><span class="w">
    </span><span class="p">[</span><span class="mi">20</span><span class="p">,</span><span class="w"> </span><span class="mi">400</span><span class="p">],</span><span class="w">
    </span><span class="p">[</span><span class="mi">210</span><span class="p">,</span><span class="w"> </span><span class="mi">400</span><span class="p">],</span><span class="w">
    </span><span class="p">[</span><span class="mi">60</span><span class="p">,</span><span class="w"> </span><span class="mi">80</span><span class="p">],</span><span class="w">
    </span><span class="p">[</span><span class="mi">150</span><span class="p">,</span><span class="w"> </span><span class="mi">200</span><span class="p">]</span><span class="w">
  </span><span class="p">]</span><span class="w">
</span><span class="p">}</span><span class="w">
</span></code></pre></div></div>

<h2 id="here-comes-opencv">Here comes OpenCV</h2>

<p>Finally, let‚Äôs do something! You need two methods.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">cv2</span><span class="p">.</span><span class="n">getPerspectiveTransform</span><span class="p">(</span> <span class="n">here_goes_list_of_src_points</span><span class="p">,</span> <span class="n">here_goes_list_of_dst_points</span> <span class="p">)</span>
</code></pre></div></div>

<p>This will return calculated homography between two flat spaces we were talking about earlier.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">cv2</span><span class="p">.</span><span class="n">perspectiveTransform</span><span class="p">(</span> <span class="n">points_we_want_to_map</span><span class="p">,</span> <span class="n">our_homography</span> <span class="p">)</span>
</code></pre></div></div>

<p>This will map other points.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="n">np</span>

<span class="n">pts_src</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="n">float32</span><span class="p">(</span><span class="n">cameraConfig</span><span class="p">[</span><span class="s">'src'</span><span class="p">])</span>
<span class="n">pts_dst</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="n">float32</span><span class="p">(</span><span class="n">cameraConfig</span><span class="p">[</span><span class="s">'dst'</span><span class="p">])</span>

<span class="n">homography</span> <span class="o">=</span> <span class="n">cv2</span><span class="p">.</span><span class="n">getPerspectiveTransform</span><span class="p">(</span><span class="n">pts_src</span><span class="p">,</span> <span class="n">pts_dst</span><span class="p">)</span>
</code></pre></div></div>

<p>Such calculated homography is enough for us to tell where we are standing in backyard. Let‚Äôs just pass where we are on the picture (here you can use some object detection or other fancy stuff) and homography.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">coords_to_map</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="n">float32</span><span class="p">([[</span> <span class="n">x_coord</span><span class="p">,</span> <span class="n">y_coord</span> <span class="p">]]).</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">)</span>
<span class="n">mapped_coords</span> <span class="o">=</span> <span class="n">cv2</span><span class="p">.</span><span class="n">perspectiveTransform</span><span class="p">(</span> <span class="n">coords_to_map</span><span class="p">,</span> <span class="n">homography</span> <span class="p">)</span>
</code></pre></div></div>

<p>Basicaly that‚Äôs it. Now go and build neighbor tracker around your house üòâ.</p>
:ET